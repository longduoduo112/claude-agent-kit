# 代码审查与重构建议（重点：路径/会话/子进程）

本文档以“可维护性、可解释性、跨平台健壮性”为准绳，对当前仓库（尤其是 `examples/claude-code-web` 与 `packages/server|websocket`）做一次工程视角的代码审查，并给出分阶段重构建议。

审查重点聚焦三类高风险区域：

1. **目录路径**：项目根、工作区根、Claude Home、可编辑目录的边界与命名。
2. **会话路径**：会话持久化桶（按 cwd 分桶）与 resume 的一致性策略。
3. **子进程**：Claude Code CLI 的 spawn、env 继承、cwd/权限模式、stderr/debug 诊断能力。

---

## 1. 结论摘要（给决策者）

整体架构方向是对的：`packages/server` 负责会话抽象，`packages/websocket` 负责连接编排，`examples/claude-code-web` 负责端到端落地；但目前存在“关键语义分散在多个层级、缺少统一的路径与会话模型”的问题，导致：

- 一旦 **cwd / 目录迁移 / UI 传参** 有细微偏差，就会触发“会话找不到”“spawn ENOENT”“Claude Code code=1 退出”等链式问题。
- 这些问题在 Windows 上更容易暴露（路径分隔符、symlink 权限、PATH 继承、进程退出码语义差异）。

建议短期用“收敛语义 + 增强可观测性”止血，中期做“路径/会话模型抽象化”，长期补齐“端到端测试 + 明确协议与状态机”。

---

## 2. 目录结构是否清晰？

### 2.1 优点（结构基本清晰）

- `packages/` 与 `examples/` 分层明确，适合“先抽象、再验证”的演进方式。
- `examples/claude-code-web` 作为“全链路样板间”很有价值：Express + Vite + ws + Session 管理一站式演示。
- `docs/reference/` 提供了会话/权限/流式输入等基础概念说明，具备继续扩展的基础。

### 2.2 问题（路径/会话相关逻辑分散与重复）

目前与“会话持久化/项目扫描/目录纠偏”相关的逻辑同时存在于：

- `packages/server/src/server/session.ts`（cwd 纠偏、resume 策略、tool_result 兜底、错误处理）
- `packages/server/src/utils/session-files.ts`（projectsRoot、读取 jsonl、扫描会话文件）
- `examples/claude-code-web/src/server/api/projects.ts`（projects 扫描与 metadata 提取）
- `examples/claude-code-web/src/server/server.ts`（WORKSPACE_DIR/WORKSPACES_DIR/CLAUDE_HOME 默认值策略）

这些逻辑的存在位置不算“错”，但缺少一个统一的“路径与会话模型”会让维护成本显著上升：你改动任意一处，都可能破坏另一处假设。

---

## 3. 代码逻辑是否混杂？是否需要重构？

### 3.1 高耦合点：`Session` 既做“业务编排”又做“底层兼容”

`packages/server/src/server/session.ts` 现在承担了过多职责：

- 会话状态机（busy/loading）
- 消息列表与通知订阅
- cwd 纠偏/目录迁移兼容
- tool_use/tool_result 解析与兜底（“执行/运行”自动批准）
- 子进程退出错误的解释与吞错策略
- 日志增强与截断

单文件过大时，常见风险是“局部修复导致全局副作用”，尤其是 **resume/cwd/错误处理** 交叉时。

**建议重构方向：按职责拆分为 3 个模块**（中期可做）：

1. `session-core.ts`：Session 状态与消息流（纯粹）。
2. `session-resume-policy.ts`：resume/cwd/目录迁移策略（可单测）。
3. `session-tool-bridge.ts`：tool_use/tool_result 的 UI 协议适配（可替换）。

### 3.2 协议不对齐：后端已支持 `toolResult`，前端尚未使用

后端协议层已支持 WebSocket 入站 `toolResult`（见 `packages/websocket/src/websocket-handler.ts:79`、`packages/server/src/types/session.ts:96`），但前端目前仍主要发送 `chat/setSDKOptions/resume`。

这会导致两种现象：

- plan 模式下需要“批准”的工具（如 `ExitPlanMode`）只能靠输入“执行/运行”做兜底，体验与可控性不足。
- 代码层面形成“后端能力 > 前端使用”，容易长期积累为死代码/半成品协议。

**建议短期**：在前端补齐“批准/拒绝”按钮，直接发送 `toolResult`，并把“输入执行”兜底降级为“兼容旧 UI”。

---

## 4. 路径体系审查（目录路径）

### 4.1 当前路径体系（建议在团队内固化为术语）

以 `examples/claude-code-web/src/server/server.ts:24` 为源头，目前存在三类根路径：

- `PROJECT_ROOT`：服务端启动目录（通常就是 `examples/claude-code-web`）。
- `WORKSPACE_DIR`：默认 `<project>/agent`，用于 Claude Code 的 `.claude/` 数据（会话、debug、skills、shell snapshots）。
- `WORKSPACES_DIR`：默认 `<project>/workspaces`，用于 UI “New Project” 的目录创建。

这次的语义分离是正确的：**Claude Home（数据）** 与 **用户工作区（内容）** 不应混在一个目录变量里。

### 4.2 仍存在的风险点

1. **命名接近，易误用**：`WORKSPACE_DIR` vs `WORKSPACES_DIR` 在阅读和传参时都容易混淆。
2. **“默认 cwd”语义容易漂移**：新会话默认 `cwd` 设为 `PROJECT_ROOT`（见 `examples/claude-code-web/src/server/server.ts:66`），但用户又会切到具体项目目录；若没有明确“哪个 cwd 影响会话持久化桶”，就容易踩坑。
3. **编码可读性问题**：部分中文注释在终端输出中出现乱码（建议统一确保源文件 UTF-8，并避免混入非 UTF-8 编码文本）。

### 4.3 建议（短期可做）

新增一个“单一真相”的路径对象（后端内部用），避免到处传散变量：

```ts
type WorkspacePaths = {
  projectRoot: string;      // PROJECT_ROOT
  claudeHome: string;       // WORKSPACE_DIR（也就是 CLAUDE_HOME）
  workspacesRoot: string;   // WORKSPACES_DIR
};
```

然后所有 API 与会话策略都只接收这个对象，禁止再传多个 string 参数“拼接猜测”。

---

## 5. 会话持久化与 resume 审查（会话路径）

### 5.1 根因机制：会话按 cwd 分桶

Claude Code 的会话文件是：

`<CLAUDE_HOME>/.claude/projects/<sanitize(cwd)>/<sessionId>.jsonl`

因此，**同 sessionId 续聊必须使用相同的 cwd 桶**，否则 CLI 会输出：

`No conversation found with session ID: <id>`（并随后 `code=1` 退出）。

这属于“外部系统（Claude Code CLI）隐含约束”，在业务层不显式建模就会反复踩坑。

### 5.2 当前实现的改进点（已止血）

`packages/server/src/server/session.ts` 已加入策略：

- 对已存在 `sessionId` 的续聊请求，优先使用 transcript 中的 `cwd` 作为本次 `options.cwd`，确保 `--resume` 在正确桶内生效（见 `packages/server/src/server/session.ts:560`）。
- 对目录迁移场景，若历史 cwd 不存在但能推断新位置，则创建目录别名（Windows 用 junction）保持兼容（见 `packages/server/src/server/session.ts:68`）。

这是一个务实的“最小修复”：不改变 Claude Code 的规则，只在服务端保证进入正确桶。

### 5.3 仍建议做的“根治化建模”（中期）

建议把 `Session` 明确持有两个概念：

- `bucketCwd`：用于 resume 的 cwd（决定 `<sanitize(cwd)>`）。
- `workingCwd`：用于工具执行/相对路径解析的 cwd（用户真正想操作的目录）。

理想情况是把这两者分离，但 Claude Code CLI 只有一个 `cwd` 参数；因此可选方案如下（需要权衡）：

#### 方案 A（保守、成本低，推荐作为默认）

- **bucketCwd = workingCwd**，强制要求“续聊不改变 cwd 桶”。
- 当用户切换项目目录时：创建新 session（或显式提示会话迁移）。

优点：简单、符合 Claude Code 直觉；缺点：对“一个会话跨多个项目目录”的场景不友好。

#### 方案 B（兼容迁移、成本中等）

- bucketCwd 固定为“会话创建时的 cwd”（或 transcript 的 cwd）。
- workingCwd 通过 `--add-dir` + MCP roots 放开目录访问，让 Claude 仍能操作用户切换到的目录。

优点：续聊稳定；缺点：需要更强的目录白名单/权限控制与 UI 表达，且调试复杂度更高。

---

## 6. 子进程（Claude Code）审查

### 6.1 已解决的典型坑

1. **Windows `spawn node ENOENT`**  
常见原因是子进程 `cwd` 不存在或 `PATH` 丢失。当前已做两类兜底：

- 传入 `executable: process.execPath`，避免依赖 PATH 寻找 node（`examples/claude-code-web/src/server/server.ts:65`）。
- 合并 env 时以 `process.env` 为底，避免覆盖掉 PATH（`packages/server/src/server/simple-cas-client.ts:89`）。

2. **“先输出错误 result，再 code=1 退出”的误报**  
外部 API/网络抖动时，Claude Code 可能先输出 `result(is_error=true)`，随后进程非 0 退出。若 SDK 抛出 exit error，UI 容易把它当崩溃。当前后端做了“已收到错误 result 时吞掉后续 code=1”的处理（详见相关实现与日志）。

### 6.2 仍建议补齐的可观测性（短期）

- 统一在服务端日志中记录：`sessionId / cwd / resume / permissionMode / executable / claudeHome` 这 6 个字段（建议做成结构化日志）。
- 对 debug：推荐支持把 `DEBUG_CLAUDE_AGENT_SDK=1` 的日志目录显式落到 `WORKSPACE_DIR/.claude/debug`，减少分散到用户 home（便于容器/CI 收集）。

---

## 7. MCP 文件系统白名单（与路径强相关）

`.mcp.json` 决定 Claude 的文件系统可访问范围。若新项目目录不在 roots 中，“自动编辑/读写”会失败并引发二次问题。

当前建议的默认 roots 组合是：

- `${PROJECT_ROOT}`：允许读写示例本身（便于改代码、看配置）。
- `${WORKSPACE_DIR}`：允许读写 Claude Home（skills/会话/调试等）。
- `${WORKSPACES_DIR}`：允许读写用户创建的新项目目录。

相关配置：`examples/claude-code-web/.mcp.json:5`。

---

## 8. 可执行重构清单（按优先级）

### P0（1~2 天，直接提升稳定性）

1. 前端补齐 `toolResult`（批准/拒绝）按钮并发送消息；把“输入执行”兜底降级为兼容逻辑。
2. 统一记录会话关键字段的结构化日志，减少“只能靠猜”的排障成本。

### P1（1~2 周，显著降低维护成本）

1. 抽出 `WorkspacePaths` 与 `SessionResumePolicy` 模块，消除路径/会话策略的分散与重复。
2. 把 `examples/claude-code-web/src/server/api/projects.ts` 的 projects 扫描逻辑下沉到 `packages/server`，形成单一实现。

### P2（持续演进，构建质量护城河）

1. 增加端到端测试：模拟 `resume -> 追加对话 -> 切换 cwd -> 再续聊` 的关键链路（至少覆盖 Windows 路径）。
2. 引入“会话迁移/修复工具”：当用户移动目录时，提供显式修复而不是靠猜测候选目录。

---

## 9. 建议新增的测试（最小集合）

1. `SessionResumePolicy` 单测：给定 transcriptCwd 与当前 cwd，验证最终 `options.cwd` 选择与别名创建行为。
2. WebSocket 协议测试：`resume -> messages_updated -> chat -> result`（模拟并断言不会触发 `No conversation found...`）。
3. Windows 兼容测试（可在 CI 上用 Windows runner）：验证 `process.execPath` 与 env 合并不会引发 `spawn ENOENT`。

---

## 10. 最后一句建议（团队协作视角）

这类系统的复杂度本质来自“外部 CLI 的隐含规则 + UI/后端的状态同步”。最有效的工程手段不是继续在各处打补丁，而是：

- **把隐含规则显式建模**（bucketCwd/workingCwd、paths 对象、协议状态机）
- **把关键链路写成测试**（resume/切 cwd/toolResult）

做到这两点，后续加功能（多项目、多模型、多 MCP server）才不会每次都回到“又是路径问题吗？”的排障循环。

