# 重构方案（聚焦“新建会话/切换会话”）

本文档用于与团队对齐一个可落地、可回滚、分阶段推进的重构计划。**明确不做**“新建项目目录 / 切换项目目录”的优化（该功能后续将被移除），本轮只聚焦：

- 新建会话（首次对话）
- 切换会话（resume/历史会话切换/刷新后继续）
- 与其强相关的：Claude Code 子进程 spawn、会话持久化桶（按 cwd 分桶）、WebSocket 协议与前端状态机

---

## 0. 背景与当前痛点（为什么要重构）

### 0.1 关键约束（必须显式建模）

Claude Code 会话持久化路径（概念层面）：

`<CLAUDE_HOME>/.claude/projects/<sanitize(cwd)>/<sessionId>.jsonl`

意味着：**同一个 sessionId 的续聊必须在相同的 cwd 桶里 resume**。否则 CLI 会输出 `No conversation found with session ID: ...`，并常以 `code=1` 退出。

### 0.2 当前问题归纳

1. **会话续聊对 cwd 过敏**：cwd 稍有变化即导致 resume 失败，出现 `code=1`、UI 误判崩溃。
2. **会话/协议状态机不完整**：后端已支持 `toolResult`，前端缺少明确的“批准/拒绝”路径，导致 plan 模式下体验不稳定（依赖“执行/运行”兜底）。
3. **会话扫描与路径策略分散**：projects 扫描、session 文件定位、cwd 纠偏等逻辑散落在多个模块，维护成本高。
4. **子进程诊断不够集中**：spawn 参数、env 合并、debug 日志位置等缺少统一“诊断视图”，排障依赖猜测。

---

## 1. 重构目标与非目标

### 1.1 目标（必须达到）

G1. **会话稳定续聊**：同一会话刷新页面/断线重连后，`resume -> 继续对话` 可稳定工作，不再因 cwd 漂移导致 `No conversation found`。  
G2. **会话切换稳定**：在 UI 中切换到任意历史会话（sessionId）后，能稳定加载 transcript 并继续对话。  
G3. **协议清晰**：WebSocket 入站/出站消息类型、sessionId 绑定规则清晰且可测试。  
G4. **计划模式可控**：plan 模式下出现 `ExitPlanMode/AskUserQuestion` 时，UI 有明确的批准/拒绝交互（不再依赖输入“执行”）。  
G5. **可观测性提升**：能快速回答“这个会话为什么失败，是 cwd 桶问题、权限问题还是上游 API 问题”。  

### 1.2 非目标（本轮不做）

- 不优化“新建项目目录 / 切换项目目录”，也不投入精力让其更完善；后续会删掉。
- 不做大型 UI 重设计（保留现有 UI 框架，只做与会话相关的必要调整）。
- 不改变 Claude Code CLI 的持久化机制（我们只能适配它的规则）。

---

## 2. 目标架构（聚焦会话的简化版）

核心思路：**把“会话桶 cwd”固定为单一稳定值**，从根上降低续聊失败概率；把“会话切换”仅与 `sessionId` 绑定。

### 2.1 “单一桶 cwd”策略（推荐默认）

- 设定一个全局稳定的 `SESSION_BUCKET_CWD`（默认 `PROJECT_ROOT`）。
- 所有会话的 `queryStream` 在 `--resume` 时都使用该 cwd（或 transcript cwd，但在“单一桶”方案下 transcript cwd 也应当一致）。
- 前端不再动态设置 cwd；后端忽略来自前端的 `setSDKOptions.cwd`（或直接从协议中移除 cwd）。

这样做的收益：

- `resume` 永远在同一个 `<sanitize(cwd)>` 桶里找会话文件，稳定性极高。
- 你后续删除“项目目录”功能时，几乎不影响会话能力。

风险与限制：

- 如果你希望在一个会话中“跨多个用户目录”进行工具读写，需要通过 MCP roots / `--add-dir` 明确授权范围（但这属于后续扩展，不影响本轮“会话稳定”目标）。

### 2.2 Session 职责拆分（中期落地）

把现有 `Session` 的职责拆成三块（便于测试与演进）：

1. `SessionCore`：消息流、busy/loading、订阅通知、startQuery/queryStream。
2. `ResumePolicy`：决定本次 query 的 `options.resume` / `options.cwd` / 目录别名策略（单一桶方案下会更简单）。
3. `ToolApprovalBridge`：处理 tool_use/tool_result（UI 发 `toolResult`，服务端转成 Claude Code 的 tool_result 消息）。

---

## 3. 分阶段实施计划（一步一步、可回滚）

下面每一阶段都包含：**改动点、涉及文件、验收标准、回滚方案**。

### 阶段 0：冻结“会话桶 cwd”，把会话从项目逻辑中解耦（P0）

**目标**：不改 UI 大结构的前提下，把“续聊失败的根因（cwd 漂移）”直接消掉。

#### 0.1 改动点

1) 在服务端引入 `SESSION_BUCKET_CWD`（环境变量 + 默认值）。
- 默认值：`PROJECT_ROOT`
- 作为 Claude Code 子进程的 `options.cwd`（至少在 `options.resume` 存在时强制使用）。

2) 服务端忽略来自前端的 `setSDKOptions.cwd`
- 仅允许前端改：`permissionMode`、`thinkingLevel`、`allowedTools`（如需）。
- `cwd` 由服务端统一控制，避免 UI/路由变化带来桶漂移。

3) 将“目录迁移别名”逻辑降级为 fallback（而不是主路径）
- 单一桶方案下，别名主要用于兼容历史会话（历史版本已写入不同 cwd 桶的 session）。

#### 0.2 涉及文件（建议改动位置）

- `examples/claude-code-web/src/server/server.ts`：新增/读取 `SESSION_BUCKET_CWD`
- `packages/server/src/server/session.ts`：在 `startQueryWithUserMessage` 构建 options 时强制使用 bucket cwd
- `packages/websocket/src/websocket-handler.ts`：在 `setSDKOptions` 时忽略/过滤 cwd 字段
- （可选）`packages/server/src/types/session.ts`：从类型层面把 cwd 标为“server-managed”（或后续阶段直接移除）

#### 0.3 验收标准

- 刷新页面后对任意历史 sessionId：`resume -> 再发一条 chat` 成功返回 `result`。
- 任意 session 连续追加 3 轮对话不出现 `No conversation found...`。
- Windows 环境下不出现 `spawn node ENOENT`（至少不由 cwd/PATH 导致）。

#### 0.4 回滚方案

- 保留原逻辑开关：`SESSION_BUCKET_CWD_STRATEGY=transcript|fixed`（默认 fixed）。
- 如出现意外影响，切回 transcript 策略即可。

---

### 阶段 1：统一“会话列表/会话详情”能力（去项目化）（P0-P1）

**目标**：前端的“切换会话”不再依赖 `/api/projects`，只基于“会话列表”即可。

#### 1.1 改动点

1) 新增后端 API：
- `GET /api/sessions`：返回历史会话列表（按 lastModified 排序）
- `GET /api/sessions/:sessionId`：返回会话详情（messages 或 summary）
- `DELETE /api/sessions/:sessionId`：删除会话（可选）

2) 复用/下沉会话扫描逻辑（避免重复实现）
- 优先使用 `packages/server/src/utils/session-files.ts` 作为单一实现。
- `examples/claude-code-web/src/server/api/projects.ts` 的扫描逻辑标记为“待移除”（后续阶段删）。

#### 1.2 涉及文件

- `examples/claude-code-web/src/server/api/index.ts`：增加 sessions 路由
- `packages/server/src/utils/session-files.ts`：若缺少“列出最近会话”的能力，在这里补齐
- `packages/server/src/server/session-manager.ts`：可直接提供 `sessionsByLastModified` 给 API 层调用（但注意脱敏字段）

#### 1.3 验收标准

- `/api/sessions` 返回可用数据（包含 sessionId、摘要、最后更新时间）。
- 任何一个 sessionId 调用 `/api/sessions/:id` 能返回 messages（或至少能标识“存在/不存在”）。

#### 1.4 回滚方案

- API 层新增不影响旧项目接口；如前端未切换到新接口，可不启用。

---

### 阶段 2：前端会话 UI 去项目化（只保留“会话列表/新建会话/切换会话”）（P1）

**目标**：UI 只做两件事：创建新会话、切换已有会话；项目目录相关 UI 仅做占位或隐藏。

#### 2.1 改动点

1) 路由简化：从 `/projects/:projectId/sessions/:sessionId` 迁移到 `/sessions/:sessionId`
- 旧路由保留一段时间做重定向（避免书签失效），但内部逻辑统一到 sessionId。

2) 左侧栏简化为：
- “新建会话”按钮（sessionId=null）
- 历史会话列表（来自 `/api/sessions`）

3) `use-web-socket` 的 resume 规则固定：
- 连接建立后读取当前路由的 sessionId，发送 `{ type: 'resume', sessionId }`
- 切换会话时只触发 resume，不触发 setSDKOptions.cwd

#### 2.2 涉及文件

- `examples/claude-code-web/src/client/App.tsx`：路由解析与会话状态绑定
- `examples/claude-code-web/src/client/hooks/use-web-socket.ts`：resume 时机与 sessionId 来源
- `examples/claude-code-web/src/client/components/LeftSidebar`（或相关组件）：改为会话列表
- （后续）删除项目相关 API/组件（本阶段先不强删，先隐藏/断开依赖）

#### 2.3 验收标准

- 新建会话：输入第一条消息即可创建 session 并正常返回。
- 切换会话：点击历史会话 -> UI 立刻显示 transcript -> 继续发送消息成功。
- 刷新页面：仍可自动 resume 当前会话并续聊成功。

---

### 阶段 3：计划模式“批准/拒绝”前端化（ToolResult UI）（P1）

**目标**：不再依赖“输入执行/运行”这种弱语义兜底；把 plan 模式的“需要确认”做成明确交互。

#### 3.1 改动点

1) 在消息渲染层识别 `tool_use`：
- 若 `name === 'ExitPlanMode'`：展示“批准执行/继续计划”按钮
- 若 `name === 'AskUserQuestion'`：展示问题 + 选项按钮（或输入框）

2) 点击按钮后发送 WebSocket：

```json
{ "type": "toolResult", "sessionId": "<current>", "toolUseId": "<id>", "content": "User approved", "isError": false }
```

3) 服务端：
- 仅做透传与会话绑定，不再做“执行/运行”自动批准的主逻辑（可保留为兼容 fallback）。

#### 3.2 涉及文件

- `examples/claude-code-web/src/client/components/messages/*`：工具消息渲染
- `examples/claude-code-web/src/client/hooks/use-web-socket.ts`：新增 `sendToolResult` 方法
- `packages/websocket/src/websocket-handler.ts`：已支持 `toolResult`，只需确保路由/绑定稳定

#### 3.3 验收标准

- plan 模式出现 ExitPlanMode：点击“批准”后，Claude 继续执行并产生后续消息。
- 不输入“执行”也能完整走通 plan -> 执行的流程。

---

### 阶段 4：收敛 Session/Resume 代码（拆模块 + 单测）（P1-P2）

**目标**：把当前 `Session` 的“大杂烩”职责拆开，形成可测试、可迭代的内部模块。

#### 4.1 改动点

1) 抽出 `resume-policy.ts`
- 输入：`sessionId`、transcript metadata、环境变量（bucket cwd）
- 输出：`effectiveCwd`、是否需要别名、可观测字段（why）

2) 抽出 `tool-approval-bridge.ts`
- 输入：toolUseId/content/isError
- 输出：SDKUserMessage（tool_result block）

3) 给 `resume-policy` 写单测（至少覆盖 Windows path / 历史 cwd 不存在）

#### 4.2 验收标准

- 关键策略有单测覆盖（cwd bucket 选择、fallback）。
- `packages/server/src/server/session.ts` 体积明显下降，核心逻辑更可读。

---

## 4. 关键设计决策（需要你确认的点）

请你重点确认下面 3 个决策是否接受；确认后我再按这个方向落地实现。

### D1：是否接受“所有会话共享同一个 cwd 桶”（固定为 PROJECT_ROOT）？

- 接受：续聊稳定性最大化，后续删项目功能更轻松。
- 不接受：需要继续支持“跨 cwd 的 session resume”，复杂度上升（需要更复杂的 bucket/working cwd 建模）。

**我的推荐**：接受（默认 fixed），保留开关以兼容历史或特殊需求。

### D2：是否从协议层禁止 `setSDKOptions.cwd`？

- 接受：前端不再能改变 cwd，减少状态漂移源。
- 不接受：仍可能从 UI 修改 cwd，需要更强的服务端校验/状态机。

**我的推荐**：接受；并在服务端做“忽略 + 日志提示”，避免旧 UI 造成误解。

### D3：会话列表来源：读磁盘 `.claude/projects` 还是读内存 `SessionManager.sessionsByLastModified`？

两种方案：

- 方案 A（读磁盘，推荐）：以“磁盘”为真相，刷新后也能列出历史会话；但需要扫描与解析成本（可做缓存）。
- 方案 B（读内存）：实现简单，但服务重启后列表丢失，不符合“会话切换”需求。

**我的推荐**：方案 A（读磁盘 + 缓存 + 限制条数，例如最近 200 条）。

---

## 5. 风险清单与应对

1) **历史会话桶不一致**：旧版本可能已在不同 cwd 桶写入过会话。  
应对：保留 transcript cwd fallback + 目录别名策略，仅用于兼容历史。

2) **Windows junction/symlink 权限差异**：部分环境禁用 symlink。  
应对：单一桶方案下几乎不需要别名；别名失败仅影响极少数历史会话，可提示用户“导出/迁移会话”。

3) **前端改动引入路由回归**：从 projects 路由迁移到 sessions 路由可能破坏书签。  
应对：保留旧路由重定向 1-2 个版本周期。

---

## 6. 验收用例（人工回归清单）

1) 新建会话：打开首页 -> 输入第一句话 -> 返回 -> 追加两句 -> 成功  
2) 切换会话：从列表选择旧会话 -> 自动加载 transcript -> 继续对话 -> 成功  
3) 刷新续聊：在会话页刷新 -> 自动 resume -> 继续对话 -> 成功  
4) plan 模式批准：触发 `ExitPlanMode` -> 点击批准按钮 -> 继续执行 -> 成功  
5) 断线重连：关闭/开启网络或刷新 ws -> 自动重连 -> resume -> 成功

---

## 7. 下一步（你确认后我做什么）

你只需要回复三件事：

1) 接受/不接受 D1（固定 bucket cwd）  
2) 接受/不接受 D2（禁用 setSDKOptions.cwd）  
3) 会话列表选择方案 A/B（推荐 A）  

确认后我会按“阶段 0 -> 阶段 3”的顺序直接开始改代码，并每完成一个阶段给你一个可运行的 checkpoint（便于你验证与回滚）。

