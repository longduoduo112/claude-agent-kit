# 重构方案（聚焦“新建会话/切换会话”）

本文档用于与团队对齐一个可落地、可回滚、分阶段推进的重构计划。**明确不做**“新建项目目录 / 切换项目目录”的优化（该功能后续将被移除），本轮只聚焦：

- 新建会话（首次对话）
- 切换会话（resume/历史会话切换/刷新后继续）
- 与其强相关的：Claude Code 子进程 spawn、会话持久化桶（按 cwd 分桶）、WebSocket 协议与前端状态机

---

## 0. 背景与当前痛点（为什么要重构）

### 0.1 关键约束（必须显式建模）

Claude Code 会话持久化路径（概念层面）：

`<CLAUDE_HOME>/.claude/projects/<sanitize(cwd)>/<sessionId>.jsonl`

意味着：**同一个 sessionId 的续聊必须在相同的 cwd 桶里 resume**。否则 CLI 会输出 `No conversation found with session ID: ...`，并常以 `code=1` 退出。

### 0.2 当前问题归纳

1. **会话续聊对 cwd 过敏**：cwd 稍有变化即导致 resume 失败，出现 `code=1`、UI 误判崩溃。
2. **会话/协议状态机不完整**：后端已支持 `toolResult`，前端缺少明确的“批准/拒绝”路径，导致 plan 模式下体验不稳定（依赖“执行/运行”兜底）。
3. **会话扫描与路径策略分散**：projects 扫描、session 文件定位、cwd 纠偏等逻辑散落在多个模块，维护成本高。
4. **子进程诊断不够集中**：spawn 参数、env 合并、debug 日志位置等缺少统一“诊断视图”，排障依赖猜测。

---

## 1. 重构目标与非目标

### 1.1 目标（必须达到）

G1. **会话稳定续聊**：同一会话刷新页面/断线重连后，`resume -> 继续对话` 可稳定工作，不再因 cwd 漂移导致 `No conversation found`。  
G2. **会话切换稳定**：在 UI 中切换到任意历史会话（sessionId）后，能稳定加载 transcript 并继续对话。  
G3. **协议清晰**：WebSocket 入站/出站消息类型、sessionId 绑定规则清晰且可测试。  
G4. **计划模式可控**：plan 模式下出现 `ExitPlanMode/AskUserQuestion` 时，UI 有明确的批准/拒绝交互（不再依赖输入“执行”）。  
G5. **可观测性提升**：能快速回答“这个会话为什么失败，是 cwd 桶问题、权限问题还是上游 API 问题”。  

### 1.2 非目标（本轮不做）

- 不优化“新建项目目录 / 切换项目目录”，也不投入精力让其更完善；后续会删掉。
- 不做大型 UI 重设计（保留现有 UI 框架，只做与会话相关的必要调整）。
- 不改变 Claude Code CLI 的持久化机制（我们只能适配它的规则）。

---

## 2. 目标架构（聚焦会话的简化版）

核心思路：**把“会话桶 cwd”固定为单一稳定值**，从根上降低续聊失败概率；把“会话切换”仅与 `sessionId` 绑定。

### 2.1 “单一桶 cwd”策略（已确认采用）

- 设定一个全局稳定的 `SESSION_BUCKET_CWD`（固定为 `PROJECT_ROOT`）。
- **所有会话（新建 + resume + 多轮续聊）** 的 Claude Code 子进程都使用该 cwd 作为桶目录（即影响 `<sanitize(cwd)>` 的那个 cwd）。
- 前端不再动态设置 cwd；后端忽略来自前端的 `setSDKOptions.cwd`（并输出明确日志提示，避免旧 UI/旧客户端误用）。

这样做的收益：

- `resume` 永远在同一个 `<sanitize(cwd)>` 桶里找会话文件，稳定性极高。
- 你后续删除“项目目录”功能时，几乎不影响会话能力。

风险与限制：

- 如果你希望在一个会话中“跨多个用户目录”进行工具读写，需要通过 MCP roots / `--add-dir` 明确授权范围（但这属于后续扩展，不影响本轮“会话稳定”目标）。

### 2.2 Session 职责拆分（中期落地）

把现有 `Session` 的职责拆成三块（便于测试与演进）：

1. `SessionCore`：消息流、busy/loading、订阅通知、startQuery/queryStream。
2. `ResumePolicy`：决定本次 query 的 `options.resume` / `options.cwd` / 目录别名策略（单一桶方案下会更简单）。
3. `ToolApprovalBridge`：处理 tool_use/tool_result（UI 发 `toolResult`，服务端转成 Claude Code 的 tool_result 消息）。

---

## 3. 分阶段实施计划（一步一步、可回滚）

下面每一阶段都包含：**改动点、涉及文件、验收标准、回滚方案**。

### 阶段 0：冻结“会话桶 cwd”，把会话从项目逻辑中解耦（P0）

**目标**：不改 UI 大结构的前提下，把“续聊失败的根因（cwd 漂移）”直接消掉。

#### 0.1 改动点

1) 在服务端引入 `SESSION_BUCKET_CWD`（环境变量 + 默认值）。
- 固定值：`PROJECT_ROOT`（本轮重构明确采用“单一桶 cwd”策略）
- 作为 Claude Code 子进程的 `options.cwd`（**新建会话与 resume 都强制使用**，避免因 cwd 漂移导致“找不到会话”）。

2) 服务端忽略来自前端的 `setSDKOptions.cwd`（保留兼容但不生效）
- 仅允许前端改：`permissionMode`、`thinkingLevel`、`allowedTools`（如需）。
- `cwd` 由服务端统一控制（固定为 `SESSION_BUCKET_CWD`），避免 UI/路由变化带来桶漂移。
- **日志提示（必须）**：当收到 `setSDKOptions.cwd` 时，记录一次 warn/info，字段至少包含：`clientId/sessionId/requestedCwd/effectiveCwd`，并提示“cwd 由服务端管理，已忽略客户端传入”。

3) 将“目录迁移别名”逻辑降级为 fallback（而不是主路径）
- 单一桶方案下，别名主要用于兼容历史会话（历史版本已写入不同 cwd 桶的 session），并且应当逐步引导用户迁移/清理旧桶。

#### 0.2 涉及文件（建议改动位置）

- `examples/claude-code-web/src/server/server.ts`：新增/读取 `SESSION_BUCKET_CWD`
- `packages/server/src/server/session.ts`：在 `startQueryWithUserMessage` 构建 options 时强制使用 bucket cwd
- `packages/websocket/src/websocket-handler.ts`：在 `setSDKOptions` 时忽略/过滤 cwd 字段
- （可选）`packages/server/src/types/session.ts`：从类型层面把 cwd 标为“server-managed”（或后续阶段直接移除）

#### 0.3 验收标准

- 刷新页面后对任意历史 sessionId：`resume -> 再发一条 chat` 成功返回 `result`。
- 任意 session 连续追加 3 轮对话不出现 `No conversation found...`。
- Windows 环境下不出现 `spawn node ENOENT`（至少不由 cwd/PATH 导致）。

#### 0.4 回滚方案

- 保留原逻辑开关：`SESSION_BUCKET_CWD_STRATEGY=transcript|fixed`（默认 fixed）。
- 如出现意外影响，切回 transcript 策略即可。

---

### 阶段 1：统一“会话列表/会话详情”能力（去项目化）（P0-P1）

**目标**：前端的“切换会话”不再依赖 `/api/projects`，只基于“会话列表”即可。

#### 1.1 改动点

1) 新增后端 API：
- `GET /api/sessions`：返回历史会话列表（按 lastModified 排序）
- `GET /api/sessions/:sessionId`：返回会话详情（messages 或 summary）
- `DELETE /api/sessions/:sessionId`：删除会话（可选）

2) 以“读磁盘”为真相，做会话列表缓存（已确认采用方案 A）
- 扫描来源：`<CLAUDE_HOME>/.claude/projects/*/*.jsonl`（等价地，通过现有 projectsRoot 推导出来）。
- 只返回最近 N 条（N=200），避免全量扫描导致启动/接口抖动。
- 缓存策略（建议默认实现）：
  - 内存缓存最近一次扫描结果（session summaries），TTL 例如 2~5 秒（UI 切换会话时足够用）。
  - 在发生“新会话写入/追加消息”（即服务端收到 `result`）后，触发一次轻量 invalidation（把缓存标记为过期）。
  - 扫描时只读取少量元信息（mtime + 文件头部几行提取 cwd/摘要/模型等），避免加载全量 messages。

3) 复用/下沉会话扫描逻辑（避免重复实现）
- 优先把“列出最近会话/读取会话摘要/读取会话详情”下沉到 `packages/server`，作为单一实现，`examples/claude-code-web` 仅做调用与序列化。
- `examples/claude-code-web/src/server/api/projects.ts` 的扫描逻辑标记为“待移除”（后续阶段删），本轮不再新增对它的依赖。

#### 1.2 涉及文件

- `examples/claude-code-web/src/server/api/index.ts`：增加 sessions 路由
- `packages/server/src/utils/session-files.ts`：若缺少“列出最近会话”的能力，在这里补齐
- `packages/server/src/server/session-manager.ts`：可直接提供 `sessionsByLastModified` 给 API 层调用（但注意脱敏字段）

#### 1.3 验收标准

- `/api/sessions` 返回可用数据（包含 sessionId、摘要、最后更新时间）。
- 任何一个 sessionId 调用 `/api/sessions/:id` 能返回 messages（或至少能标识“存在/不存在”）。

#### 1.4 回滚方案

- API 层新增不影响旧项目接口；如前端未切换到新接口，可不启用。

---

### 阶段 2：前端会话 UI 去项目化（只保留“会话列表/新建会话/切换会话”）（P1）

**目标**：UI 只做两件事：创建新会话、切换已有会话；项目目录相关 UI 仅做占位或隐藏。

#### 2.1 改动点

1) 路由简化：从 `/projects/:projectId/sessions/:sessionId` 迁移到 `/sessions/:sessionId`
- 旧路由保留一段时间做重定向（避免书签失效），但内部逻辑统一到 sessionId。

2) 左侧栏简化为：
- “新建会话”按钮（sessionId=null）
- 历史会话列表（来自 `/api/sessions`）

3) `use-web-socket` 的 resume 规则固定：
- 连接建立后读取当前路由的 sessionId，发送 `{ type: 'resume', sessionId }`
- 切换会话时只触发 resume，不触发 setSDKOptions.cwd

#### 2.2 涉及文件

- `examples/claude-code-web/src/client/App.tsx`：路由解析与会话状态绑定
- `examples/claude-code-web/src/client/hooks/use-web-socket.ts`：resume 时机与 sessionId 来源
- `examples/claude-code-web/src/client/components/LeftSidebar`（或相关组件）：改为会话列表
- （后续）删除项目相关 API/组件（本阶段先不强删，先隐藏/断开依赖）

#### 2.3 验收标准

- 新建会话：输入第一条消息即可创建 session 并正常返回。
- 切换会话：点击历史会话 -> UI 立刻显示 transcript -> 继续发送消息成功。
- 刷新页面：仍可自动 resume 当前会话并续聊成功。

---

### 阶段 3：计划模式“批准/拒绝”前端化（ToolResult UI）（P1）

**目标**：不再依赖“输入执行/运行”这种弱语义兜底；把 plan 模式的“需要确认”做成明确交互。

#### 3.1 改动点

1) 在消息渲染层识别 `tool_use`：
- 若 `name === 'ExitPlanMode'`：展示“批准执行/继续计划”按钮
- 若 `name === 'AskUserQuestion'`：展示问题 + 选项按钮（或输入框）

2) 点击按钮后发送 WebSocket：

```json
{ "type": "toolResult", "sessionId": "<current>", "toolUseId": "<id>", "content": "User approved", "isError": false }
```

3) 服务端：
- 仅做透传与会话绑定，不再做“执行/运行”自动批准的主逻辑（可保留为兼容 fallback）。

#### 3.2 涉及文件

- `examples/claude-code-web/src/client/components/messages/*`：工具消息渲染
- `examples/claude-code-web/src/client/hooks/use-web-socket.ts`：新增 `sendToolResult` 方法
- `packages/websocket/src/websocket-handler.ts`：已支持 `toolResult`，只需确保路由/绑定稳定

#### 3.3 验收标准

- plan 模式出现 ExitPlanMode：点击“批准”后，Claude 继续执行并产生后续消息。
- 不输入“执行”也能完整走通 plan -> 执行的流程。

---

### 阶段 4：收敛 Session/Resume 代码（拆模块 + 单测）（P1-P2）

**目标**：把当前 `Session` 的“大杂烩”职责拆开，形成可测试、可迭代的内部模块。

#### 4.1 改动点

1) 抽出 `resume-policy.ts`
- 输入：`sessionId`、transcript metadata、环境变量（bucket cwd）
- 输出：`effectiveCwd`、是否需要别名、可观测字段（why）

2) 抽出 `tool-approval-bridge.ts`
- 输入：toolUseId/content/isError
- 输出：SDKUserMessage（tool_result block）

3) 给 `resume-policy` 写单测（至少覆盖 Windows path / 历史 cwd 不存在）

#### 4.2 验收标准

- 关键策略有单测覆盖（cwd bucket 选择、fallback）。
- `packages/server/src/server/session.ts` 体积明显下降，核心逻辑更可读。

---

## 4. 关键设计决策（已对齐）

已确认采用如下决策（作为后续实现的约束条件）：

- D1：接受“所有会话共享同一个 cwd 桶”，固定为 `PROJECT_ROOT`（即 `SESSION_BUCKET_CWD=PROJECT_ROOT`）。
- D2：接受从协议层禁止/忽略 `setSDKOptions.cwd`；服务端对旧客户端传入 cwd 做“忽略 + 日志提示”。
- D3：会话列表采用方案 A：读磁盘为真相 + 内存缓存 + 限制条数（默认最近 200 条）。

---

## 5. 风险清单与应对

1) **历史会话桶不一致**：旧版本可能已在不同 cwd 桶写入过会话。  
应对：保留 transcript cwd fallback + 目录别名策略，仅用于兼容历史。

2) **Windows junction/symlink 权限差异**：部分环境禁用 symlink。  
应对：单一桶方案下几乎不需要别名；别名失败仅影响极少数历史会话，可提示用户“导出/迁移会话”。

3) **前端改动引入路由回归**：从 projects 路由迁移到 sessions 路由可能破坏书签。  
应对：保留旧路由重定向 1-2 个版本周期。

---

## 6. 验收用例（人工回归清单）

1) 新建会话：打开首页 -> 输入第一句话 -> 返回 -> 追加两句 -> 成功  
2) 切换会话：从列表选择旧会话 -> 自动加载 transcript -> 继续对话 -> 成功  
3) 刷新续聊：在会话页刷新 -> 自动 resume -> 继续对话 -> 成功  
4) plan 模式批准：触发 `ExitPlanMode` -> 点击批准按钮 -> 继续执行 -> 成功  
5) 断线重连：关闭/开启网络或刷新 ws -> 自动重连 -> resume -> 成功

---

## 7. 下一步（实施顺序）

在不改“项目目录”相关功能的前提下，按以下顺序推进实现最稳妥：

1) 先做阶段 0（固定 `SESSION_BUCKET_CWD` + 忽略 cwd 入参 + 必要日志）——立刻提升续聊稳定性。
2) 再做阶段 1（`/api/sessions` 系列接口 + 磁盘扫描缓存 + 最近 200 条）——为前端去项目化做数据基础。
3) 再做阶段 2（前端路由与左侧栏去项目化，仅保留新建/切换会话）——完成“只剩会话”的产品形态。
4) 最后做阶段 3（toolResult UI）——把 plan 模式的“批准/拒绝”从兜底变成标准交互。

如你对该实施顺序也无异议，我下一步会按阶段 0 开始落地代码改动，并在每个阶段完成后给你一个可运行 checkpoint 便于验证与回滚。
